# Rust SpaceCAN

## Overview

Rust SpaceCAN is a Rust workspace project implementing a CAN (Controller Area Network) protocol stack and firmware for embedded systems. It consists of two main crates:

- `spacecan`: A no_std Rust library providing CAN frame encoding, decoding, and protocol services.
- `spacecan-firmware`: Minimal firmware targeting STM32F4Discovery hardware implementation.
- `spacecan-virtual`: Virtual implementation of SpaceCAN for testing and simulation.

The project aims to provide a robust, embedded-friendly CAN protocol implementation with simulation support.

## ðŸ“Œ Project Structure

```
rust-spacecan/
|   â”œâ”€â”€spacecan/
â”‚   |   â”œâ”€â”€ src/
â”‚   |   |   â”œâ”€â”€ primitives/       # Core communication components
â”‚   â”‚   |   |   â”œâ”€â”€ can_frame.rs        # CAN Frame struct & serialization
â”‚   â”‚   |   |   â”œâ”€â”€ heartbeat.rs        # Heartbeat signal processing
â”‚   â”‚   |   |   â”œâ”€â”€ network.rs          # CAN network handling
â”‚   â”‚   |   |   â”œâ”€â”€ packet.rs           # Packet fragmentation & reassembly
â”‚   â”‚   |   |   â”œâ”€â”€ sync.rs             # Sync message handling
â”‚   â”‚   |   |   â”œâ”€â”€ timer.rs            # Periodic task scheduling
â”‚   |   |   â”œâ”€â”€ services/        # Service layer components
â”‚   â”‚   |   |   â”œâ”€â”€ core.rs              # Packet routing & processing
â”‚   â”‚   |   |   â”œâ”€â”€ ST01_request_verification.rs  # Request verification
â”‚   â”‚   |   |   â”œâ”€â”€ ST03_housekeeping.rs          # Housekeeping service
â”‚   â”‚   |   |   â”œâ”€â”€ ST08_function_management.rs   # Function management
â”‚   â”‚   |   |   â”œâ”€â”€ ST17_test.rs                  # System test service
â”‚   â”‚   |   |   â”œâ”€â”€ ST20_parameter_management.rs  # Parameter management
â”‚   |   |   â”œâ”€â”€ transport/       # Low-level transport layer
â”‚   â”‚   |   |   â”œâ”€â”€ base.rs              # Bus implementation
â”‚   â”‚   |   |   â”œâ”€â”€ frame_buffer.rs       # Frame buffering
â”‚   â”‚   |   |   â”œâ”€â”€ mock.rs         # Mock implementation
â”‚   |   |   â”œâ”€â”€ tests/           # Unit test suite
â”‚   |   |   |   â”œâ”€â”€ test_base.rs         # Unit tests for Bus implementation
â”‚   |   |   |   â”œâ”€â”€ test_can_frame.rs    # Unit tests for CAN frames
â”‚   |   |   |   â”œâ”€â”€ test_core.rs         # Unit tests for packet processing
â”‚   |   |   |   â”œâ”€â”€ test_heartbeat.rs    # Unit tests for heartbeat service
â”‚   |   |   |   â”œâ”€â”€ test_packet.rs       # Unit tests for packet fragmentation
â”‚   |   |   |   â”œâ”€â”€ test_sync.rs         # Unit tests for sync processing
â”‚   |   |   |   â”œâ”€â”€ test_timer.rs        # Unit tests for timer module
â”‚   |   â”œâ”€â”€ examples/                     # Example implementations
â”‚   |   |   â”œâ”€â”€ basic/
|   |   |   |   â”œâ”€â”€ heartbeat_example.rs    # Basic heartbeat example
|   |   |   |   â”œâ”€â”€ receive_can.rs          # Receive CAN example
|   |   |   |   â”œâ”€â”€ send_can.rs             # Send CAN example
|   |   |   |   â”œâ”€â”€ sync_example.rs         # Sync example
|   |   |   â”œâ”€â”€ packet/
|   |   |   |   â”œâ”€â”€ full_packet_demo.rs    # Full packet demo
|   |   |   |   â”œâ”€â”€ reassemblepacket.rs    # Reassemble packet example
|   |   |   |   â”œâ”€â”€ split_packet.rs    # Split packet example
|   |   |   â”œâ”€â”€ services/
|   |   |   |   â”œâ”€â”€ packet_service.rs   # packet service example
|   |   |   |   â”œâ”€â”€ service_full_demo.rs    #servive full demo
|   |   |   |   â”œâ”€â”€ service_splitter.rs    #service splitter example
|   |   |   â”œâ”€â”€ README.md   #documentation for examples
|   |   |   â””â”€â”€ vcan.sh   #vcan documentation
|   |   â”œâ”€â”€ docs/
|   |   |   â”œâ”€â”€ECSS-E-ST-50-15C.pdf    #ECSS standard defining CAN application layer.
|   |   |   â”œâ”€â”€ECSS-E-ST-70-41C(15April2016).pdf    #ECSS Telecommand/Telemetry protocol document.
|   |   â”œâ”€â”€ Cargo.toml    # Rust package configuration
|   |   â”œâ”€â”€ Cargo.lock    #Lock file for dependency versions
|   â”œâ”€â”€spacecan-firmware/
|   |   â”œâ”€â”€ src/
|   |   |   â”œâ”€â”€ main.rs    #Main entry point for firmware
|   |   |   â”œâ”€â”€ lib.rs     #Library part of firmware crate
|   |   â”œâ”€â”€examples/
|   |   |   â”œâ”€â”€ firmware.rs    #Firmware example
|   |   |   â”œâ”€â”€release  #release file
|   |   â”œâ”€â”€Cargo.lock   #Lock file for dependency versions
|   |   â”œâ”€â”€Cargo.toml   # Rust package configuration
|   |   â”œâ”€â”€memory.x     #Memory configuration file
|   |   â”œâ”€â”€thumbv7em-none-eabihf.json    #Target configuration file
|   â”œâ”€â”€spacecan-virtual/
|   |   â”œâ”€â”€ src/
|   |   |   â”œâ”€â”€ main.rs    #Main entry point for virtual implementation
|   |   â”œâ”€â”€ Cargo.toml    # Rust package configuration
|   |   â”œâ”€â”€ README.md    #Project Documentation
|   |   â”œâ”€â”€ controller.rs    #Controller implementation
|   |   â”œâ”€â”€ responder.rs     #Responder implementation
|   â”œâ”€â”€ README.md               # Project documentation
|   â”œâ”€â”€ CONTRIBUTING.md         # Contribution guidelines
|   â”œâ”€â”€ LICENSE.md              # Project license
|   â”œâ”€â”€ Cargo.toml              # Rust package configuration
|   â”œâ”€â”€ Cargo.lock              #Lock file for dependency versions

```

## Workspace Structure

- `spacecan/`: Core CAN protocol library and examples.
- `spacecan-firmware/`: Firmware implementation for STM32F4Discovery.
- `spacecan-virtual/`: Virtual implementation for testing and simulation.

## Building the Project

Ensure you have Rust installed with the appropriate target for embedded ARM Cortex-M:

```bash
rustup target add thumbv7em-none-eabihf
```

### Build the entire workspace

From the root directory:

```bash
cargo build --release
```

### Build individual crates

- Build `spacecan` library:

```bash
cargo build --release -p spacecan
```

- Build `spacecan-firmware` firmware:

```bash
cargo build --release -p spacecan-firmware
```

- Build `spacecan-virtual` virtual implementation:

```bash
cargo build --release -p spacecan-virtual
```

## Running Specific Implementations

To avoid interchanging the virtual and firmware implementations, always explicitly build and run the desired crate.

### Running spacecan-virtual

#### Prerequisites

- Rust toolchain installed (preferably nightly for latest features)
- Cargo package manager
- Virtual CAN interface (e.g., `vcan0`) set up on your Linux system

To set up the virtual CAN interface, run the following commands with root privileges:

```bash
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
```

#### Build and Run

Build the package with async features enabled:

```bash
cargo build --release --features async -p spacecan-virtual
```

Run the example responder or controller binaries:

```bash
cargo run --release --features async --bin responder -p spacecan-virtual
```

```bash
cargo run --release --features async --bin controller -p spacecan-virtual
```

---

### Running spacecan-firmware

#### Prerequisites

- Rust installed with the appropriate target for embedded ARM Cortex-M:

```bash
rustup target add thumbv7em-none-eabihf
```

#### Build and Run

Build the firmware:

```bash
cargo build --release -p spacecan-firmware
```

Run the firmware:

```bash
cargo run -p spacecan-firmware
```

Or using the Cargo alias:

```bash
cargo run-firmware
```




## Running the Mock Example in `spacecan`

The `spacecan` crate includes a mock transport example demonstrating CAN frame encoding and decoding.

To run the example (requires std feature enabled):

```bash
cargo run --example heartbeat_example --features std
```

This example encodes a heartbeat CAN frame, sends it via a mock transport, and decodes it back.

## Running the Firmware in Renode Simulation

The firmware is designed to run on an STM32F4Discovery board.

## Dependencies and Features

- `spacecan` is a no_std crate by default, with optional `std` feature for examples and testing.
- Uses embedded Rust crates such as `cortex-m`, `embedded-hal`, `stm32f7xx-hal`, and `bxcan`.
- `spacecan-firmware` depends on `spacecan` and hardware abstraction layers for STM32F7 series.
- `spacecan-virtual` depends on `spacecan` and provides a virtual implementation for testing.

## Additional Notes

- The project uses a linked list allocator for dynamic memory in no_std environments.
- Panic handling is minimal and designed for embedded constraints.
- The Renode scripts define the hardware peripherals and memory layout for simulation.

## Contributing

Contributions and improvements are welcome. Please follow Rust embedded best practices.

For detailed contribution guidelines, please see the [CONTRIBUTING.md](CONTRIBUTING.md) file.

## License

This project is licensed under the terms specified in the [LICENSE.md](LICENSE.md) file.
[text](thumbv7em-none-eabihf.json)
---

For detailed usage or developer guides, additional documentation can be added in the `docs/` directory.

---
